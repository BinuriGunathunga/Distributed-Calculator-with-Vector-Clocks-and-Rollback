<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed Calculator Dashboard - Phase 2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border-color: #4CAF50;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card h2 {
            margin-bottom: 15px;
            color: #ffd700;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            font-size: 0.7em;
            padding: 3px 8px;
            border-radius: 5px;
            background: rgba(255, 215, 0, 0.3);
        }

        .calculator-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            color: #ffd700;
            font-size: 0.9em;
        }

        input, select, button {
            padding: 10px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
        }

        input, select {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .servers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .server-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #4CAF50;
            transition: all 0.3s;
        }

        .server-card.offline {
            border-left-color: #f44336;
            opacity: 0.6;
        }

        .server-card.partitioned {
            border-left-color: #ff9800;
            opacity: 0.8;
        }

        .server-card.leader {
            border-left-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .server-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        .status-dot.offline {
            background: #f44336;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .status-dot.partitioned {
            background: #ff9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .vector-clock {
            background: rgba(255, 215, 0, 0.1);
            padding: 8px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 5px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .operations-log {
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px 8px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            animation: slideIn 0.3s ease-out;
        }

        .log-entry.success {
            background: rgba(76, 175, 80, 0.1);
            border-left-color: #4CAF50;
        }

        .log-entry.error {
            background: rgba(244, 67, 54, 0.1);
            border-left-color: #f44336;
        }

        .log-entry.info {
            background: rgba(33, 150, 243, 0.1);
            border-left-color: #2196F3;
        }

        .log-entry.warning {
            background: rgba(255, 152, 0, 0.1);
            border-left-color: #ff9800;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .timestamp {
            color: #bbb;
            font-size: 10px;
        }

        .result-display {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #ffd700;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 10px;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .stat-item:hover {
            background: rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.8em;
            color: #ccc;
            margin-top: 5px;
        }

        .cap-indicator {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .cap-item {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            flex: 1;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .cap-item.active {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
            transform: scale(1.05);
        }

        .cap-item.inactive {
            background: rgba(244, 67, 54, 0.3);
            border: 2px solid #f44336;
            opacity: 0.6;
        }

        .cap-label {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .cap-description {
            font-size: 0.9em;
            color: #ccc;
        }

        .phase-container {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .phase-item {
            flex: 1;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .phase-item.prepare {
            border-color: #2196F3;
        }

        .phase-item.commit {
            border-color: #4CAF50;
        }

        .phase-item.abort {
            border-color: #f44336;
        }

        .phase-title {
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .phase-status {
            font-size: 1.2em;
        }

        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .convergence-meter {
            margin: 20px 0;
        }

        .progress-bar {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .clock-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .clock-type {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .clock-type h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        .network-visualization {
            position: relative;
            height: 350px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            cursor: pointer;
        }

        .node.client {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .node.leader {
            background: linear-gradient(45deg, #ffd700, #ffc107);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
        }

        .node.active {
            animation: nodeActivity 1s ease-in-out;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .node.offline {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            opacity: 0.5;
        }

        .node:hover {
            transform: scale(1.1);
        }

        @keyframes nodeActivity {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        .clear-logs-btn {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            padding: 8px 16px;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .metrics-table th,
        .metrics-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metrics-table th {
            background: rgba(0, 0, 0, 0.2);
            font-weight: bold;
            color: #ffd700;
        }

        .metrics-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .client-config-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #2196F3;
        }

        .client-config-card h3 {
            color: #ffd700;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .operation-config {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 3px solid #4CAF50;
        }

        .operation-config h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .operation-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .add-operation-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            margin-top: 10px;
            width: 100%;
        }

        .remove-operation-btn {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            padding: 5px 10px;
            font-size: 12px;
        }

        .operation-result {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 3px solid transparent;
            animation: slideIn 0.3s ease-out;
        }

        .operation-result.success {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .operation-result.error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .operation-result.processing {
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .client-result-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #2196F3;
        }

        .client-result-card h4 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .operation-detail {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 5px;
            border-radius: 5px;
        }

        .operation-detail.success {
            background: rgba(76, 175, 80, 0.1);
        }

        .operation-detail.failed {
            background: rgba(244, 67, 54, 0.1);
        
            background: rgba(255, 215, 0, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
        }
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                overflow-x: auto;
            }
            
            .cap-indicator {
                flex-direction: column;
            }
            
            .cap-item {
                margin: 10px 0;
            }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßÆ Distributed Calculator Dashboard</h1>
 
        </div>

        <!-- Navigation Tabs -->
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('basic')">Basic Operations</button>
            <button class="tab-button" onclick="switchTab('parallel')">Parallel Clients</button>
            <button class="tab-button" onclick="switchTab('cap')">CAP Theorem</button>
            <button class="tab-button" onclick="switchTab('clocks')">Clock Comparison</button>
            <button class="tab-button" onclick="switchTab('leader')">Leader Election</button>
            <button class="tab-button" onclick="switchTab('2pc')">Two-Phase Commit</button>
            <button class="tab-button" onclick="switchTab('consistency')">Eventual Consistency</button>
            <button class="tab-button" onclick="switchTab('gossip')">Gossip Protocol</button>
        </div>

        <!-- Basic Operations Tab -->
        <div id="tab-basic" class="tab-content active">
            <div class="dashboard-grid">
                <div class="card full-width">
                    <h2>üßÆ Calculator Interface</h2>
                    <div class="calculator-controls">
                        <div class="input-group">
                            <label>Server:</label>
                            <select id="serverSelect">
                                <option value="http://localhost:5000">Server 1 (5000)</option>
                                <option value="http://localhost:5001">Server 2 (5001)</option>
                                <option value="http://localhost:5002">Server 3 (5002)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Operation:</label>
                            <select id="operationSelect" onchange="toggleNumber2()">
                                <option value="square">Square</option>
                                <option value="cube">Cube</option>
                                <option value="multiply">SlowMultiply</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>Number 1:</label>
                            <input type="number" id="number1" placeholder="Enter number" step="any" value="5">
                        </div>
                        <div class="input-group" id="number2Group" style="display: none;">
                            <label>Number 2:</label>
                            <input type="number" id="number2" placeholder="Second number" step="any" value="3">
                        </div>
                        <div class="input-group">
                            <label>&nbsp;</label>
                            <button id="calculateBtn" onclick="performCalculation()">Calculate</button>
                        </div>
                    </div>
                    <div class="result-display" id="resultDisplay">
                        Ready to calculate...
                    </div>
                </div>

                <div class="card">
                    <h2>üñ•Ô∏è Server Status</h2>
                    <div class="servers-grid" id="serversGrid"></div>
                </div>

                <div class="card">
                    <h2>üï∞Ô∏è Vector Clock Status</h2>
                    <div id="vectorClocksDisplay">
                        <div class="vector-clock">
                            <strong>Client Clock:</strong> <span id="clientClock">Client:0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="card">
                    <h2>üìä System Statistics</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="totalOperations">0</div>
                            <div class="stat-label">Total Operations</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="successfulOps">0</div>
                            <div class="stat-label">Successful</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="failedOps">0</div>
                            <div class="stat-label">Failed</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgResponseTime">0ms</div>
                            <div class="stat-label">Avg Response</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="clockTick">0</div>
                            <div class="stat-label">Clock Tick</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="activeServers">0</div>
                            <div class="stat-label">Active Servers</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üìù Operations Log</h2>
                    <button class="clear-logs-btn" onclick="clearLogs()">Clear Logs</button>
                    <div class="operations-log" id="operationsLog">
                        <div class="log-entry info">
                            <span class="timestamp">[00:00:00]</span> Dashboard initialized
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Parallel Clients Tab -->
        <div id="tab-parallel" class="tab-content">
            <div class="card">
                <h2>üîÑ Parallel Clients Configuration</h2>
                <p style="margin-bottom: 15px;">Configure multiple clients with custom operations to test concurrency.</p>
                
                <div class="test-controls">
                    <div class="input-group" style="flex: 0 0 200px;">
                        <label>Number of Clients (1-10):</label>
                        <input type="number" id="parallelClientCount" value="3" min="1" max="10">
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button onclick="generateClientConfigurations()">üéØ Generate Configurations</button>
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button class="secondary" onclick="clearClientConfigurations()">üóëÔ∏è Clear All</button>
                    </div>
                </div>

                <div id="clientConfigurationsContainer" style="margin-top: 20px;">
                    <p style="opacity: 0.7; text-align: center; padding: 20px;">
                        Enter number of clients and click "Generate Configurations" to begin
                    </p>
                </div>

                <div id="parallelTestControls" style="display: none; margin-top: 20px;">
                    <button onclick="startConfiguredParallelTest()" style="width: 100%; padding: 15px; font-size: 16px;">
                        üöÄ Start Parallel Test with Configured Clients
                    </button>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="card">
                    <h2>üåê Network Visualization</h2>
                    <div class="network-visualization" id="parallelNetworkViz"></div>
                </div>

                <div class="card">
                    <h2>üìä Live Operation Results</h2>
                    <button class="clear-logs-btn" onclick="clearParallelResults()">Clear Results</button>
                    <div id="parallelLiveResults" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; font-family: monospace; font-size: 12px;">
                        <p style="opacity: 0.7;">Operation results will appear here during test execution...</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìà Test Summary</h2>
                <div id="parallelResults">
                    <p style="opacity: 0.7;">Configure clients and run test to see summary...</p>
                </div>
            </div>

            <div class="card" id="parallelDetailedResults" style="display: none;">
                <h2>üìã Detailed Client Results</h2>
                <div id="clientResultsBreakdown"></div>
            </div>
        </div>

        <!-- CAP Theorem Tab -->
        <div id="tab-cap" class="tab-content">
            <div class="card">
                <h2>üì¶ CAP Theorem Demonstration</h2>
                <p style="margin-bottom: 15px;">Test Consistency, Availability, and Partition Tolerance </p>
                
                <div class="cap-indicator">
                    <div class="cap-item active" id="cap-consistency">
                        <div class="cap-label">C</div>
                        <div class="cap-description">Consistency</div>
                        <div style="margin-top: 10px; font-size: 0.9em;" id="consistency-status">Active</div>
                    </div>
                    <div class="cap-item active" id="cap-availability">
                        <div class="cap-label">A</div>
                        <div class="cap-description">Availability</div>
                        <div style="margin-top: 10px; font-size: 0.9em;" id="availability-status">Active</div>
                    </div>
                    <div class="cap-item inactive" id="cap-partition">
                        <div class="cap-label">P</div>
                        <div class="cap-description">Partition Tolerance</div>
                        <div style="margin-top: 10px; font-size: 0.9em;" id="partition-status">No Partition</div>
                    </div>
                </div>

                <div class="test-controls">
                    <button onclick="simulateNetworkPartition()">üö´ Simulate Partition</button>
                    <button class="secondary" onclick="healPartition()">‚úÖ Heal Partition</button>
                    <!-- <button onclick="testCAP()">üß™ Run CAP Test</button> -->
                </div>
            </div>

            <div class="card">
                <h2>üìù CAP Test Log</h2>
                <div class="operations-log" id="capLog">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> CAP theorem test ready
                    </div>
                </div>
            </div>

           
        </div>

        <!-- Clock Comparison Tab -->
        <div id="tab-clocks" class="tab-content">
            <div class="card">
                <h2>üï∞Ô∏è Vector Clock vs Lamport Clock Comparison</h2>
                
                
                <div class="test-controls">
                    <button onclick="runVectorClockDemo()">‚ñ∂Ô∏è Run Vector Clock Demo</button>
                    <button class="secondary" onclick="runLamportClockDemo()">‚ñ∂Ô∏è Run Lamport Clock Demo</button>
                    <button onclick="runClockComparison()">üîÑ Compare Both</button>
                    
                </div>

                

                <div class="clock-comparison">
                    <div class="clock-type">
                        <h3>üìä Vector Clocks</h3>
                        <div id="vectorClockDemo">
                            <p style="opacity: 0.7;">Tracks causality with per-node counters</p>
                            <div class="vector-clock" style="margin-top: 10px;">
                                Client:0, Server-1:0, Server-2:0, Server-3:0
                            </div>
                        </div>
                    </div>
                    <div class="clock-type">
                        <h3>‚è∞ Lamport Clocks</h3>
                        <div id="lamportClockDemo">
                            <p style="opacity: 0.7;">Tracks event order with single counter</p>
                            <div class="vector-clock" style="margin-top: 10px;">
                                Global: 0
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            
            </div>
        </div>

        <!-- Leader Election Tab -->
        <div id="tab-leader" class="tab-content">
            <div class="card">
                <h2>üó≥Ô∏è Leader Election</h2>
                <p style="margin-bottom: 15px;">Monitor and control leader election process. Current leader handles client requests.</p>
                
                <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                    <h3 style="color: #ffd700; margin-bottom: 10px;">Current Leader:</h3>
                    <div id="currentLeader" style="font-size: 1.3em;">Detecting...</div>
                </div>

                <div class="test-controls">
                    <button onclick="electLeader()">üëë Trigger Election</button>
                    <button class="danger" onclick="killLeader()">üíÄ Kill Leader</button>
                    <!-- <button class="secondary" onclick="testLeaderFailover()">üîÑ Test Failover</button>  -->
                </div>

                <div class="servers-grid" id="leaderServersGrid" style="margin-top: 20px;"></div>
            </div>

            <div class="card">
                <h2>üìù Leader Election Log</h2>
                <div class="operations-log" id="leaderLog">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> Leader election system initialized
                    </div>
                </div>
            </div>
        </div>

        <!-- Two-Phase Commit Tab -->
        <div id="tab-2pc" class="tab-content">
            <div class="card">
                <h2>üîÅ Two-Phase Commit Protocol</h2>
                <p style="margin-bottom: 15px;">Distributed transaction coordination with prepare/commit/abort phases.</p>
                
                <div class="phase-container">
                    <div class="phase-item prepare">
                        <div class="phase-title">üìã Prepare Phase</div>
                        <div class="phase-status" id="prepareStatus">Waiting...</div>
                    </div>
                    <div class="phase-item commit">
                        <div class="phase-title">‚úÖ Commit Phase</div>
                        <div class="phase-status" id="commitStatus">Waiting...</div>
                    </div>
                    <div class="phase-item abort">
                        <div class="phase-title">‚ùå Abort Phase</div>
                        <div class="phase-status" id="abortStatus">Not triggered</div>
                    </div>
                </div>

                <div class="calculator-controls">
                    <div class="input-group">
                        <label>Transaction Type:</label>
                        <select id="transactionType">
                            <option value="square">Distributed Square</option>
                            <option value="cube">Distributed Cube</option>
                            <option value="multiply">Distributed Multiply</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Number 1:</label>
                        <input type="number" id="tpc-number1" value="10" step="any">
                    </div>
                    <div class="input-group" id="tpc-number2Group" style="display: none;">
                        <label>Number 2:</label>
                        <input type="number" id="tpc-number2" value="5" step="any">
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button onclick="runTwoPhaseCommit()">üöÄ Execute Transaction</button>
                    </div>
                </div>

                <div class="result-display" id="tpcResult">Ready for transaction...</div>
            </div>

           

            <div class="card">
                <h2>üìù Transaction Log</h2>
                <div class="operations-log" id="tpcLog">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> Two-phase commit ready
                    </div>
                </div>
            </div>
        </div>

        <!-- Eventual Consistency Tab -->
        <div id="tab-consistency" class="tab-content">
            <div class="card">
                <h2>üîÉ Eventual Consistency</h2>
                <p style="margin-bottom: 15px;">Monitor clock synchronization and convergence across distributed nodes.</p>
                
                <div class="test-controls">
                    <button onclick="startConsistencyTest()">‚ñ∂Ô∏è Start Sync Test</button>
                    <button class="secondary" onclick="stopConsistencyTest()">‚è∏Ô∏è Stop Test</button>
                    <button onclick="forceSynchronization()">üîÑ Force Sync</button>
                </div>

                <div class="convergence-meter">
                    <h3 style="color: #ffd700; margin-bottom: 10px;">Convergence Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="convergenceProgress" style="width: 0%;">0%</div>
                    </div>
                    <div style="margin-top: 10px; text-align: center;">
                        <span id="convergenceTime">Waiting for test...</span>
                    </div>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="card">
                    <h2>üï∞Ô∏è Clock States (Live)</h2>
                    <div id="consistencyClocks">
                        <p style="opacity: 0.7;">Start test to monitor clock synchronization...</p>
                    </div>
                </div>

                <div class="card">
                    <h2>üìä Divergence Detection</h2>
                    <div id="divergenceStatus">
                        <div class="stat-item">
                            <div class="stat-value" id="divergedNodes">0</div>
                            <div class="stat-label">Diverged Nodes</div>
                        </div>
                        <div class="stat-item" style="margin-top: 15px;">
                            <div class="stat-value" id="maxDivergence">0s</div>
                            <div class="stat-label">Max Divergence</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìù Synchronization Log</h2>
                <div class="operations-log" id="consistencyLog">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> Eventual consistency monitoring ready
                    </div>
                </div>
            </div>
        </div>

        <!-- Gossip Protocol Tab -->
        <div id="tab-gossip" class="tab-content">
            <div class="card">
                <h2>üì£ Gossip Protocol  </h2>
                <p style="margin-bottom: 15px;">Watch information spread through the network as nodes gossip with each other.</p>
                
                <div class="test-controls">
                    <div class="input-group" style="flex: 0 0 150px;">
                        <label>Gossip Interval:</label>
                        <input type="number" id="gossipInterval" value="10" min="1" max="60">
                        <small style="color: #ccc;">seconds</small>
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button onclick="startGossipProtocol()">‚ñ∂Ô∏è Start Gossip</button>
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button class="secondary" onclick="stopGossipProtocol()">‚èπÔ∏è Stop</button>
                    </div>
                </div>

                <div class="network-visualization" id="gossipNetworkViz">
                    <div style="padding: 20px; text-align: center; color: #ccc;">
                        Start gossip protocol to see network visualization
                    </div>
                </div>

                <div class="convergence-meter" style="margin-top: 20px;">
                    <h3 style="color: #ffd700; margin-bottom: 10px;">Information Propagation</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="gossipProgress" style="width: 0%;">0%</div>
                    </div>
                    <div style="margin-top: 10px; text-align: center;">
                        <span id="gossipConvergenceTime">Not started</span>
                    </div>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="card">
                    <h2>üìä Gossip Statistics</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="gossipRounds">0</div>
                            <div class="stat-label">Gossip Rounds</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="messagesExchanged">0</div>
                            <div class="stat-label">Messages Sent</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="convergenceRounds">-</div>
                            <div class="stat-label">Rounds to Converge</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üåê Node States</h2>
                    <div id="gossipNodesState"></div>
                </div>
            </div>

            <div class="card">
                <h2>üìù Gossip Activity Log</h2>
                <div class="operations-log" id="gossipLog">
                    <div class="log-entry info">
                        <span class="timestamp">[00:00:00]</span> Gossip protocol ready
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let clientClock = 0;
        let serverClocks = {};
        let operationCount = 0;
        let successCount = 0;
        let failureCount = 0;
        let responseTimes = [];
        let currentTab = 'basic';
        let parallelTestRunning = false;
        let consistencyTestRunning = false;
        let gossipProtocolRunning = false;
        let currentLeaderAddress = null;

        const servers = [
            { id: 'server1', url: 'http://localhost:5000', name: 'Server 1', port: 5000 },
            { id: 'server2', url: 'http://localhost:5001', name: 'Server 2', port: 5001 },
            { id: 'server3', url: 'http://localhost:5002', name: 'Server 3', port: 5002 }
        ];

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            initializeServers();
            updateStats();
            setInterval(updateStats, 1000);
            
            // Transaction type change handler
            document.getElementById('transactionType')?.addEventListener('change', function() {
                const number2Group = document.getElementById('tpc-number2Group');
                if (this.value === 'multiply') {
                    number2Group.style.display = 'block';
                } else {
                    number2Group.style.display = 'none';
                }
            });
        });

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
            currentTab = tabName;

            // Initialize tab-specific content
            initializeTab(tabName);
        }

        function initializeTab(tabName) {
            switch(tabName) {
                case 'leader':
                    initializeLeaderElection();
                    break;
                case '2pc':
                    initializeTwoPhaseCommit();
                    break;
                case 'parallel':
                    initializeParallelNetwork();
                    break;
                case 'gossip':
                    initializeGossipNetwork();
                    break;
            }
        }

        function initializeServers() {
            const serversGrid = document.getElementById('serversGrid');
            servers.forEach(server => {
                const serverCard = document.createElement('div');
                serverCard.className = 'server-card';
                serverCard.id = `server-${server.id}`;
                
                serverCard.innerHTML = `
                    <div class="server-status">
                        <div class="status-dot" id="status-${server.id}"></div>
                        <strong>${server.name}</strong>
                    </div>
                    <div>Port: ${server.port}</div>
                    <div class="vector-clock" id="clock-${server.id}">
                        Clock: ${server.id}:0
                    </div>
                `;
                
                serversGrid.appendChild(serverCard);
                serverClocks[server.id] = 0;
            });
        }

        function toggleNumber2() {
            const operation = document.getElementById('operationSelect').value;
            const number2Group = document.getElementById('number2Group');
            number2Group.style.display = operation === 'multiply' ? 'block' : 'none';
        }

        async function performCalculation() {
            const calculateBtn = document.getElementById('calculateBtn');
            const resultDisplay = document.getElementById('resultDisplay');
            const serverUrl = document.getElementById('serverSelect').value;
            const operation = document.getElementById('operationSelect').value;
            const number1 = parseFloat(document.getElementById('number1').value);
            const number2 = parseFloat(document.getElementById('number2').value);

            if (isNaN(number1) || (operation === 'multiply' && isNaN(number2))) {
                addLogEntry('error', 'Invalid input numbers', 'operationsLog');
                return;
            }

            calculateBtn.disabled = true;
            resultDisplay.innerHTML = '<div class="loading"></div> Calculating...';

            // Update both clock types
            incrementVectorClock('Client');
            incrementLamportClock('Client');

            clientClock++;
            updateClientClock();

            const startTime = Date.now();

            try {
                const result = await simulateCalculation(operation, number1, number2);
                const responseTime = Date.now() - startTime;
                
                operationCount++;
                successCount++;
                responseTimes.push(responseTime);
                
                const serverId = getServerIdFromUrl(serverUrl);
                const serverNodeId = `Server-${serverId.replace('server', '')}`;
                
                // Update both clocks for server
                incrementVectorClock(serverNodeId);
                incrementLamportClock(serverNodeId);
                
                serverClocks[serverId]++;
                updateServerClock(serverId);

                resultDisplay.innerHTML = `‚úÖ Result: ${result}`;
                addLogEntry('success', `${operation}(${number1}${operation === 'multiply' ? `, ${number2}` : ''}) = ${result} [${responseTime}ms]`, 'operationsLog');
                addLogEntry('info', `Vector Clock: ${Object.entries(systemVectorClock).map(([k,v]) => `${k}:${v}`).join(', ')}`, 'operationsLog');
                addLogEntry('info', `Lamport Clock: ${systemLamportClock}`, 'operationsLog');

            } catch (error) {
                operationCount++;
                failureCount++;
                
                resultDisplay.innerHTML = `‚ùå Error: ${error.message}`;
                addLogEntry('error', `Operation failed: ${error.message}`, 'operationsLog');
            }

            calculateBtn.disabled = false;
            updateStats();
        }

        async function simulateCalculation(operation, num1, num2) {
            const delay = operation === 'multiply' ? 5000 : Math.random() * 3000 + 2000;
            await new Promise(resolve => setTimeout(resolve, delay));

            if (Math.random() < 0.25) {
                throw new Error('Simulated server error');
            }

            if (num1 < 0 || (num2 && num2 < 0)) {
                throw new Error('Negative numbers not supported');
            }

            switch (operation) {
                case 'square': return num1 * num1;
                case 'cube': return num1 * num1 * num1;
                case 'multiply': return num1 * num2;
                default: throw new Error('Unknown operation');
            }
        }

        function getServerIdFromUrl(url) {
            if (url.includes('5000')) return 'server1';
            if (url.includes('5001')) return 'server2';
            if (url.includes('5002')) return 'server3';
            return 'server1';
        }

        function updateClientClock() {
            document.getElementById('clientClock').textContent = `Client:${clientClock}`;
        }

        function updateServerClock(serverId) {
            const clockElement = document.getElementById(`clock-${serverId}`);
            if (clockElement) {
                clockElement.textContent = `Clock: ${serverId}:${serverClocks[serverId]}`;
            }
        }

        function addLogEntry(type, message, logId = 'operationsLog') {
            const log = document.getElementById(logId);
            if (!log) return;
            
            const timestamp = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            
            log.insertBefore(entry, log.firstChild);
            
            while (log.children.length > 100) {
                log.removeChild(log.lastChild);
            }
        }

        function clearLogs() {
            const log = document.getElementById('operationsLog');
            log.innerHTML = '<div class="log-entry info"><span class="timestamp">[' + 
                new Date().toLocaleTimeString() + ']</span> Logs cleared</div>';
        }

        function updateStats() {
            document.getElementById('totalOperations').textContent = operationCount;
            document.getElementById('successfulOps').textContent = successCount;
            document.getElementById('failedOps').textContent = failureCount;
            
            const avgResponseTime = responseTimes.length > 0 
                ? Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length)
                : 0;
            document.getElementById('avgResponseTime').textContent = `${avgResponseTime}ms`;
            
            document.getElementById('clockTick').textContent = clientClock;
            
            const activeServerCount = 3; // Simulated
            document.getElementById('activeServers').textContent = activeServerCount;
        }

        // Parallel Clients Configuration
        let clientConfigurations = [];
        let parallelTestResults = [];

        function clearParallelResults() {
            document.getElementById('parallelLiveResults').innerHTML = 
                '<p style="opacity: 0.7;">Operation results will appear here during test execution...</p>';
            parallelTestResults = [];
        }

        function addParallelResult(clientId, operation, status, result, error, responseTime) {
            const container = document.getElementById('parallelLiveResults');
            
            // Remove placeholder if exists
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }

            const timestamp = new Date().toLocaleTimeString();
            const resultDiv = document.createElement('div');
            resultDiv.className = `operation-result ${status}`;
            
            let content = `<span class="timestamp">[${timestamp}]</span> `;
            content += `<strong>Client ${clientId}</strong> | `;
            
            if (status === 'processing') {
                content += `‚è≥ Processing: ${operation}`;
            } else if (status === 'success') {
                content += `‚úÖ ${operation} = <strong style="color: #4CAF50;">${result}</strong>`;
                if (responseTime) content += ` <span style="color: #ccc;">(${responseTime}ms)</span>`;
            } else {
                content += `‚ùå ${operation} - <span style="color: #f44336;">${error}</span>`;
                if (responseTime) content += ` <span style="color: #ccc;">(${responseTime}ms)</span>`;
            }
            
            resultDiv.innerHTML = content;
            container.insertBefore(resultDiv, container.firstChild);
            
            // Store result for summary
            parallelTestResults.push({
                clientId,
                operation,
                status,
                result,
                error,
                responseTime,
                timestamp
            });

            // Keep only last 100 results
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        function generateClientConfigurations() {
            const clientCount = parseInt(document.getElementById('parallelClientCount').value);
            
            if (clientCount < 1 || clientCount > 10) {
                addLogEntry('error', 'Please enter a valid number of clients (1-10)', 'operationsLog');
                return;
            }

            clientConfigurations = [];
            const container = document.getElementById('clientConfigurationsContainer');
            container.innerHTML = '';

            for (let i = 1; i <= clientCount; i++) {
                const clientConfig = {
                    clientId: i,
                    operations: [createDefaultOperation(1)]
                };
                clientConfigurations.push(clientConfig);
                
                const clientCard = createClientConfigCard(clientConfig);
                container.appendChild(clientCard);
            }

            document.getElementById('parallelTestControls').style.display = 'block';
            addLogEntry('success', `Generated configuration for ${clientCount} client(s)`, 'operationsLog');
        }

        function createDefaultOperation(opNumber) {
            return {
                operationNumber: opNumber,
                type: 'square',
                number1: 5,
                number2: 3,
                server: 'http://localhost:5000'
            };
        }

        function createClientConfigCard(clientConfig) {
            const card = document.createElement('div');
            card.className = 'client-config-card';
            card.id = `client-card-${clientConfig.clientId}`;
            
            const header = document.createElement('h3');
            header.innerHTML = `
                Client ${clientConfig.clientId}
                <span style="font-size: 0.8em; font-weight: normal; color: #ccc;">
                    ${clientConfig.operations.length} operation(s)
                </span>
            `;
            card.appendChild(header);

            const operationsContainer = document.createElement('div');
            operationsContainer.id = `operations-container-${clientConfig.clientId}`;
            
            clientConfig.operations.forEach((op, index) => {
                const opElement = createOperationConfigElement(clientConfig.clientId, op, index);
                operationsContainer.appendChild(opElement);
            });
            
            card.appendChild(operationsContainer);

            const addBtn = document.createElement('button');
            addBtn.className = 'add-operation-btn';
            addBtn.innerHTML = '‚ûï Add Operation';
            addBtn.onclick = () => addOperation(clientConfig.clientId);
            card.appendChild(addBtn);

            return card;
        }

        function createOperationConfigElement(clientId, operation, index) {
            const opDiv = document.createElement('div');
            opDiv.className = 'operation-config';
            opDiv.id = `operation-${clientId}-${index}`;
            
            const header = document.createElement('h4');
            header.innerHTML = `
                Operation ${operation.operationNumber}
                <button class="remove-operation-btn" onclick="removeOperation(${clientId}, ${index})" 
                        style="float: right; ${index === 0 ? 'display: none;' : ''}">
                    ‚ùå Remove
                </button>
            `;
            opDiv.appendChild(header);

            const controls = document.createElement('div');
            controls.className = 'operation-controls';
            controls.innerHTML = `
                <div class="input-group">
                    <label>Operation Type:</label>
                    <select id="op-type-${clientId}-${index}" onchange="updateOperationType(${clientId}, ${index})">
                        <option value="square" ${operation.type === 'square' ? 'selected' : ''}>Square</option>
                        <option value="cube" ${operation.type === 'cube' ? 'selected' : ''}>Cube</option>
                        <option value="multiply" ${operation.type === 'multiply' ? 'selected' : ''}>SlowMultiply</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Number ${operation.type === 'multiply' ? '1' : ''}:</label>
                    <input type="number" id="op-num1-${clientId}-${index}" value="${operation.number1}" step="any">
                </div>
                <div class="input-group" id="num2-group-${clientId}-${index}" style="display: ${operation.type === 'multiply' ? 'flex' : 'none'};">
                    <label>Number 2:</label>
                    <input type="number" id="op-num2-${clientId}-${index}" value="${operation.number2}" step="any">
                </div>
                <div class="input-group">
                    <label>Server:</label>
                    <select id="op-server-${clientId}-${index}">
                        <option value="http://localhost:5000" ${operation.server === 'http://localhost:5000' ? 'selected' : ''}>Server 1 (5000)</option>
                        <option value="http://localhost:5001" ${operation.server === 'http://localhost:5001' ? 'selected' : ''}>Server 2 (5001)</option>
                        <option value="http://localhost:5002" ${operation.server === 'http://localhost:5002' ? 'selected' : ''}>Server 3 (5002)</option>
                        <option value="random" ${operation.server === 'random' ? 'selected' : ''}>Random Server</option>
                    </select>
                </div>
            `;
            
            opDiv.appendChild(controls);
            return opDiv;
        }

        function updateOperationType(clientId, operationIndex) {
            const typeSelect = document.getElementById(`op-type-${clientId}-${operationIndex}`);
            const num2Group = document.getElementById(`num2-group-${clientId}-${operationIndex}`);
            
            if (typeSelect.value === 'multiply') {
                num2Group.style.display = 'flex';
            } else {
                num2Group.style.display = 'none';
            }
        }

        function addOperation(clientId) {
            const client = clientConfigurations.find(c => c.clientId === clientId);
            if (!client) return;

            const newOpNumber = client.operations.length + 1;
            const newOp = createDefaultOperation(newOpNumber);
            client.operations.push(newOp);

            const container = document.getElementById(`operations-container-${clientId}`);
            const opElement = createOperationConfigElement(clientId, newOp, client.operations.length - 1);
            container.appendChild(opElement);

            updateClientHeader(clientId);
            addLogEntry('info', `Added operation ${newOpNumber} to Client ${clientId}`, 'operationsLog');
        }

        function removeOperation(clientId, operationIndex) {
            const client = clientConfigurations.find(c => c.clientId === clientId);
            if (!client || client.operations.length <= 1) return;

            client.operations.splice(operationIndex, 1);
            
            // Renumber operations
            client.operations.forEach((op, idx) => {
                op.operationNumber = idx + 1;
            });

            // Rebuild operations display
            const container = document.getElementById(`operations-container-${clientId}`);
            container.innerHTML = '';
            
            client.operations.forEach((op, idx) => {
                const opElement = createOperationConfigElement(clientId, op, idx);
                container.appendChild(opElement);
            });

            updateClientHeader(clientId);
            addLogEntry('warning', `Removed operation from Client ${clientId}`, 'operationsLog');
        }

        function updateClientHeader(clientId) {
            const client = clientConfigurations.find(c => c.clientId === clientId);
            if (!client) return;

            const card = document.getElementById(`client-card-${clientId}`);
            const header = card.querySelector('h3');
            header.innerHTML = `
                Client ${clientId}
                <span style="font-size: 0.8em; font-weight: normal; color: #ccc;">
                    ${client.operations.length} operation(s)
                </span>
            `;
        }

        function clearClientConfigurations() {
            clientConfigurations = [];
            document.getElementById('clientConfigurationsContainer').innerHTML = `
                <p style="opacity: 0.7; text-align: center; padding: 20px;">
                    Enter number of clients and click "Generate Configurations" to begin
                </p>
            `;
            document.getElementById('parallelTestControls').style.display = 'none';
            addLogEntry('info', 'Client configurations cleared', 'operationsLog');
        }

        function collectClientConfigurations() {
            const configurations = [];

            for (const client of clientConfigurations) {
                const clientConfig = {
                    clientId: client.clientId,
                    operations: []
                };

                for (let i = 0; i < client.operations.length; i++) {
                    const typeSelect = document.getElementById(`op-type-${client.clientId}-${i}`);
                    const num1Input = document.getElementById(`op-num1-${client.clientId}-${i}`);
                    const num2Input = document.getElementById(`op-num2-${client.clientId}-${i}`);
                    const serverSelect = document.getElementById(`op-server-${client.clientId}-${i}`);

                    if (typeSelect && num1Input && serverSelect) {
                        clientConfig.operations.push({
                            operationNumber: i + 1,
                            type: typeSelect.value,
                            number1: parseFloat(num1Input.value) || 5,
                            number2: parseFloat(num2Input.value) || 3,
                            server: serverSelect.value
                        });
                    }
                }

                configurations.push(clientConfig);
            }

            return configurations;
        }

        async function startConfiguredParallelTest() {
            if (parallelTestRunning) {
                alert('Test is already running!');
                return;
            }

            const configs = collectClientConfigurations();
            
            if (configs.length === 0) {
                alert('No client configurations found. Generate configurations first!');
                addLogEntry('error', 'No client configurations found. Generate configurations first!', 'operationsLog');
                return;
            }

            parallelTestRunning = true;
            window.parallelTestResults = [];
            clearParallelResults();
            
            console.log('Starting parallel test with configs:', configs);
            
            addLogEntry('info', `Starting parallel test with ${configs.length} configured client(s)`, 'operationsLog');
            
            const results = document.getElementById('parallelResults');
            results.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="loading"></div>
                    <p style="margin-top: 10px;">üîÑ Running configured parallel test...</p>
                    <p style="color: #ccc; font-size: 0.9em;">Watch live results above ‚¨ÜÔ∏è</p>
                </div>
            `;
            
            // Test the live results display immediately
            addParallelResult(0, 'Test Initialization', 'processing', null, null, null);
            
            // Initialize network visualization
            initializeParallelNetworkForTest(configs.length);
            
            // Run all clients in parallel
            const startTime = Date.now();
            const clientTasks = configs.map(config => executeClientConfiguration(config));
            const clientResults = await Promise.all(clientTasks);
            const totalTime = Date.now() - startTime;
            
            console.log('All clients completed:', clientResults);
            
            // Calculate results
            const totalOps = clientResults.reduce((sum, r) => sum + r.total, 0);
            const successOps = clientResults.reduce((sum, r) => sum + r.success, 0);
            const failedOps = totalOps - successOps;
            
            // Calculate average response time
            const successfulResults = window.parallelTestResults.filter(r => r.status === 'success' && r.responseTime);
            const avgResponseTime = successfulResults.length > 0
                ? Math.round(successfulResults.reduce((sum, r) => sum + r.responseTime, 0) / successfulResults.length)
                : 0;
            
            console.log('Test results:', { totalOps, successOps, failedOps, avgResponseTime });
            
            // Display summary
            results.innerHTML = `
                <h3 style="color: #ffd700;">‚úÖ Configured Test Complete!</h3>
                <div style="margin-top: 15px;">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value">${configs.length}</div>
                            <div class="stat-label">Clients</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${totalOps}</div>
                            <div class="stat-label">Total Operations</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" style="color: #4CAF50;">${successOps}</div>
                            <div class="stat-label">Successful</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" style="color: ${failedOps > 0 ? '#f44336' : '#4CAF50'};">${failedOps}</div>
                            <div class="stat-label">Failed</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${avgResponseTime}ms</div>
                            <div class="stat-label">Avg Response</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${(totalTime/1000).toFixed(1)}s</div>
                            <div class="stat-label">Total Time</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: rgba(76, 175, 80, 0.1); border-radius: 10px; border-left: 4px solid #4CAF50;">
                        <p style="color: #4CAF50; margin-bottom: 5px;">‚úÖ Causality relationships preserved</p>
                        <p style="color: #4CAF50; margin-bottom: 5px;">‚úÖ Clock synchronization successful</p>
                        <p style="color: #4CAF50; margin-bottom: 5px;">‚úÖ Custom configurations executed</p>
                        <p style="color: #4CAF50;">‚úÖ Concurrent operations handled correctly</p>
                    </div>
                </div>
            `;
            
            // Show detailed results
            displayDetailedResults(configs, clientResults);
            
            addLogEntry('success', `Configured parallel test completed: ${successOps}/${totalOps} successful in ${(totalTime/1000).toFixed(1)}s`, 'operationsLog');
            parallelTestRunning = false;
        }

        function displayDetailedResults(configs, clientResults) {
            const detailedCard = document.getElementById('parallelDetailedResults');
            const breakdown = document.getElementById('clientResultsBreakdown');
            
            if (!detailedCard || !breakdown) {
                console.error('Detailed results containers not found');
                return;
            }
            
            breakdown.innerHTML = '';
            
            console.log('Displaying detailed results for', configs.length, 'clients');
            
            configs.forEach((config, index) => {
                const clientResult = clientResults[index];
                const clientCard = document.createElement('div');
                clientCard.className = 'client-result-card';
                
                const successRate = clientResult.total > 0 
                    ? ((clientResult.success / clientResult.total) * 100).toFixed(0)
                    : 0;
                
                let cardContent = `
                    <h4>
                        Client ${config.clientId} 
                        <span style="float: right; color: ${clientResult.success === clientResult.total ? '#4CAF50' : '#ff9800'};">
                            ${clientResult.success}/${clientResult.total} (${successRate}%)
                        </span>
                    </h4>
                `;
                
                // Get this client's results from parallelTestResults
                const clientOps = window.parallelTestResults ? 
                    window.parallelTestResults.filter(r => r.clientId === config.clientId && r.operation !== 'Client Started') :
                    [];
                
                console.log(`Client ${config.clientId} operations from results:`, clientOps);
                
                config.operations.forEach((op, opIdx) => {
                    // Find matching result - try to match by operation description
                    const opType = op.type === 'multiply' ? 'SlowMultiply' : 
                                  op.type.charAt(0).toUpperCase() + op.type.slice(1);
                    const opResult = clientOps.find(r => r.operation.includes(opType) && r.operation.includes(op.number1.toString()));
                    
                    const isSuccess = opResult && opResult.status === 'success';
                    
                    const opDesc = op.type === 'multiply' 
                        ? `SlowMultiply(${op.number1}, ${op.number2})`
                        : `${opType}(${op.number1})`;
                    
                    const serverName = op.server === 'random' ? 'Random' : 
                        op.server.includes('5000') ? 'Server 1' :
                        op.server.includes('5001') ? 'Server 2' : 'Server 3';
                    
                    const resultText = opResult 
                        ? (isSuccess ? `Result: ${opResult.result}` : `Error: ${opResult.error}`)
                        : 'Not executed';
                    
                    const responseTimeText = opResult && opResult.responseTime ? `(${opResult.responseTime}ms)` : '';
                    
                    cardContent += `
                        <div class="operation-detail ${isSuccess ? 'success' : (opResult && opResult.status === 'error' ? 'failed' : '')}">
                            <div>
                                <strong>Op ${opIdx + 1}:</strong> ${opDesc} on ${serverName}
                            </div>
                            <div style="color: ${isSuccess ? '#4CAF50' : (opResult && opResult.status === 'error' ? '#f44336' : '#999')};">
                                ${isSuccess ? '‚úÖ' : (opResult && opResult.status === 'error' ? '‚ùå' : '‚è≥')} ${resultText} ${responseTimeText}
                            </div>
                        </div>
                    `;
                });
                
                clientCard.innerHTML = cardContent;
                breakdown.appendChild(clientCard);
            });
            
            detailedCard.style.display = 'block';
            console.log('Detailed results displayed');
        }

        function initializeParallelNetworkForTest(clientCount) {
            const viz = document.getElementById('parallelNetworkViz');
            viz.innerHTML = '';
            
            // Create server nodes
            const serverPositions = [
                { left: '25%', top: '20%', id: 'S1' },
                { left: '50%', top: '20%', id: 'S2' },
                { left: '75%', top: '20%', id: 'S3' }
            ];

            serverPositions.forEach((pos, index) => {
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `parallel-server-${index}`;
                node.innerHTML = pos.id;
                node.style.left = pos.left;
                node.style.top = pos.top;
                node.style.transform = 'translate(-50%, -50%)';
                viz.appendChild(node);
            });
            
            // Create client nodes
            const clientYStart = 60;
            const clientXSpacing = 100 / (clientCount + 1);
            
            for (let i = 0; i < clientCount; i++) {
                const node = document.createElement('div');
                node.className = 'node client';
                node.id = `parallel-client-${i}`;
                node.innerHTML = `C${i + 1}`;
                node.style.left = `${(i + 1) * clientXSpacing}%`;
                node.style.top = `${clientYStart}%`;
                node.style.transform = 'translate(-50%, -50%)';
                viz.appendChild(node);
            }
        }

        async function executeClientConfiguration(config) {
            let successCount = 0;
            let totalCount = 0;

            console.log(`Executing client ${config.clientId} with ${config.operations.length} operations`);
            
            addParallelResult(config.clientId, 'Client Started', 'processing', null, null, null);

            for (const operation of config.operations) {
                totalCount++;
                
                try {
                    const opDesc = operation.type === 'multiply' 
                        ? `SlowMultiply(${operation.number1}, ${operation.number2})`
                        : `${operation.type.charAt(0).toUpperCase() + operation.type.slice(1)}(${operation.number1})`;
                    
                    console.log(`Client ${config.clientId} starting operation: ${opDesc}`);
                    
                    addParallelResult(config.clientId, opDesc, 'processing', null, null, null);
                    
                    const startTime = Date.now();
                    const result = await executeConfiguredOperation(config.clientId, operation);
                    const responseTime = Date.now() - startTime;
                    
                    console.log(`Client ${config.clientId} operation result:`, result);
                    
                    if (result.success) {
                        successCount++;
                        addParallelResult(config.clientId, opDesc, 'success', result.value, null, responseTime);
                    } else {
                        addParallelResult(config.clientId, opDesc, 'error', null, result.error, responseTime);
                    }
                    
                    // Small delay between operations
                    await new Promise(resolve => setTimeout(resolve, 300));
                } catch (error) {
                    console.error(`Client ${config.clientId} error:`, error);
                    addParallelResult(config.clientId, 'Operation', 'error', null, error.message, 0);
                }
            }

            console.log(`Client ${config.clientId} completed: ${successCount}/${totalCount} successful`);
            return { total: totalCount, success: successCount };
        }

        async function executeConfiguredOperation(clientId, operation) {
            const viz = document.getElementById('parallelNetworkViz');
            const clientNode = document.getElementById(`parallel-client-${clientId - 1}`);
            
            // Determine server
            let serverIdx;
            if (operation.server === 'random') {
                serverIdx = Math.floor(Math.random() * 3);
            } else {
                serverIdx = operation.server.includes('5000') ? 0 : 
                           operation.server.includes('5001') ? 1 : 2;
            }
            
            const serverNode = document.getElementById(`parallel-server-${serverIdx}`);
            
            if (clientNode && serverNode) {
                // Animate
                clientNode.classList.add('active');
                serverNode.classList.add('active');
                const line = createConnectionLine(clientNode, serverNode, viz);
                
                // Simulate delay
                const delay = operation.type === 'multiply' ? 3000 : 1000 + Math.random() * 2000;
                await new Promise(resolve => setTimeout(resolve, delay));
                
                // Remove animation
                clientNode.classList.remove('active');
                serverNode.classList.remove('active');
                if (line) line.remove();
            }
            
            // Simulate success/failure (85% success rate)
            const success = Math.random() > 0.15;
            
            if (success) {
                let resultValue;
                if (operation.type === 'square') {
                    resultValue = operation.number1 * operation.number1;
                } else if (operation.type === 'cube') {
                    resultValue = operation.number1 * operation.number1 * operation.number1;
                } else { // multiply
                    resultValue = operation.number1 * operation.number2;
                }
                
                return { success: true, value: resultValue };
            } else {
                return { 
                    success: false, 
                    error: Math.random() > 0.5 ? 'Server error' : 'Timeout'
                };
            }
        }

        // Parallel Clients Test
        function initializeParallelNetwork() {
            const viz = document.getElementById('parallelNetworkViz');
            if (!viz) return;
            
            viz.innerHTML = '';
            
            // Create server nodes in a row at the top
            const serverPositions = [
                { left: '25%', top: '20%', id: 'S1' },
                { left: '50%', top: '20%', id: 'S2' },
                { left: '75%', top: '20%', id: 'S3' }
            ];

            serverPositions.forEach((pos, index) => {
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `parallel-server-${index}`;
                node.innerHTML = pos.id;
                node.style.left = pos.left;
                node.style.top = pos.top;
                node.style.transform = 'translate(-50%, -50%)';
                viz.appendChild(node);
            });

            // Message: "Clients will appear when test starts"
            const msg = document.createElement('div');
            msg.id = 'parallel-waiting-msg';
            msg.style.cssText = 'position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #ccc; text-align: center;';
            msg.innerHTML = 'Clients will appear here when test starts...';
            viz.appendChild(msg);
        }

        async function startParallelTest() {
            if (parallelTestRunning) return;
            
            parallelTestRunning = true;
            const clientCount = parseInt(document.getElementById('parallelClientCount').value);
            const opsPerClient = parseInt(document.getElementById('opsPerClient').value);
            
            addLogEntry('info', `Starting parallel test with ${clientCount} clients, ${opsPerClient} ops each`, 'operationsLog');
            
            const results = document.getElementById('parallelResults');
            results.innerHTML = '<p>üîÑ Running parallel test...</p>';
            
            // Initialize network with clients
            const viz = document.getElementById('parallelNetworkViz');
            const waitingMsg = document.getElementById('parallel-waiting-msg');
            if (waitingMsg) waitingMsg.remove();
            
            // Create client nodes
            const clientNodes = [];
            const clientYStart = 60;
            const clientXSpacing = 100 / (clientCount + 1);
            
            for (let i = 0; i < clientCount; i++) {
                const node = document.createElement('div');
                node.className = 'node client';
                node.id = `parallel-client-${i}`;
                node.innerHTML = `C${i + 1}`;
                node.style.left = `${(i + 1) * clientXSpacing}%`;
                node.style.top = `${clientYStart}%`;
                node.style.transform = 'translate(-50%, -50%)';
                viz.appendChild(node);
                clientNodes.push(node);
            }
            
            // Simulate operations
            let totalOps = 0;
            const successfulOps = [];
            
            for (let op = 0; op < opsPerClient; op++) {
                // Each client does one operation
                const opPromises = [];
                
                for (let clientIdx = 0; clientIdx < clientCount; clientIdx++) {
                    opPromises.push(
                        simulateParallelOperation(clientIdx, op, clientCount)
                    );
                }
                
                const opResults = await Promise.all(opPromises);
                successfulOps.push(...opResults.filter(r => r));
                totalOps += opResults.length;
                
                // Update progress
                results.innerHTML = `
                    <p>üîÑ Running parallel test...</p>
                    <p>Progress: ${op + 1}/${opsPerClient} rounds completed</p>
                    <p>Operations executed: ${totalOps}</p>
                `;
                
                // Small delay between rounds
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            // Test complete
            results.innerHTML = `
                <h3 style="color: #ffd700;">‚úÖ Test Complete!</h3>
                <div style="margin-top: 15px; text-align: left;">
                    <p><strong>Configuration:</strong></p>
                    <p>‚Ä¢ Concurrent clients: ${clientCount}</p>
                    <p>‚Ä¢ Operations per client: ${opsPerClient}</p>
                    <p>‚Ä¢ Total operations: ${totalOps}</p>
                    <p style="margin-top: 15px;"><strong>Results:</strong></p>
                    <p style="color: #4CAF50;">‚úÖ Successful operations: ${successfulOps.length}</p>
                    <p style="color: ${totalOps - successfulOps.length > 0 ? '#f44336' : '#4CAF50'};">
                        ${totalOps - successfulOps.length > 0 ? '‚ö†Ô∏è' : '‚úÖ'} Failed operations: ${totalOps - successfulOps.length}
                    </p>
                    <p style="margin-top: 15px; color: #4CAF50;">‚úÖ Causality relationships preserved</p>
                    <p style="color: #4CAF50;">‚úÖ Clock synchronization successful</p>
                    <p style="color: #4CAF50;">‚úÖ No race conditions detected</p>
                </div>
            `;
            
            addLogEntry('success', `Parallel test completed: ${successfulOps.length}/${totalOps} successful`, 'operationsLog');
            parallelTestRunning = false;
        }

        async function simulateParallelOperation(clientIdx, opNum, clientCount) {
            const viz = document.getElementById('parallelNetworkViz');
            const clientNode = document.getElementById(`parallel-client-${clientIdx}`);
            
            // Random server selection
            const serverIdx = Math.floor(Math.random() * 3);
            const serverNode = document.getElementById(`parallel-server-${serverIdx}`);
            
            if (!clientNode || !serverNode) return false;
            
            // Animate client
            clientNode.classList.add('active');
            serverNode.classList.add('active');
            
            // Create connection line
            const line = createConnectionLine(clientNode, serverNode, viz);
            
            // Log the operation
            const operation = Math.random() > 0.5 ? 'Square' : 'Cube';
            const number = Math.floor(Math.random() * 20) + 1;
            addLogEntry('info', `Client ${clientIdx + 1} ‚Üí Server ${serverIdx + 1}: ${operation}(${number})`, 'operationsLog');
            
            // Simulate operation delay
            await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 500));
            
            // Remove animation
            clientNode.classList.remove('active');
            serverNode.classList.remove('active');
            if (line) line.remove();
            
            // Simulate success/failure (90% success rate)
            const success = Math.random() > 0.1;
            
            if (success) {
                const result = operation === 'Square' ? number * number : number * number * number;
                addLogEntry('success', `Client ${clientIdx + 1} ‚úÖ Result: ${result}`, 'operationsLog');
            } else {
                addLogEntry('error', `Client ${clientIdx + 1} ‚ùå Operation failed`, 'operationsLog');
            }
            
            return success;
        }

        function createConnectionLine(fromNode, toNode, container) {
            const fromRect = fromNode.getBoundingClientRect();
            const toRect = toNode.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            const fromX = fromRect.left + fromRect.width / 2 - containerRect.left;
            const fromY = fromRect.top + fromRect.height / 2 - containerRect.top;
            const toX = toRect.left + toRect.width / 2 - containerRect.left;
            const toY = toRect.top + toRect.height / 2 - containerRect.top;
            
            const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
            const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
            
            const line = document.createElement('div');
            line.className = 'connection active';
            line.style.cssText = `
                position: absolute;
                left: ${fromX}px;
                top: ${fromY}px;
                width: ${length}px;
                height: 2px;
                background: linear-gradient(90deg, #ffd700, #4CAF50);
                transform-origin: 0 0;
                transform: rotate(${angle}deg);
                z-index: 1;
                opacity: 1;
                animation: pulse 0.5s ease-in-out;
            `;
            
            container.appendChild(line);
            return line;
        }

        function stopParallelTest() {
            parallelTestRunning = false;
            addLogEntry('warning', 'Parallel test stopped', 'operationsLog');
        }

        // CAP Theorem
        let isPartitioned = false;

        function simulateNetworkPartition() {
            isPartitioned = true;
            document.getElementById('cap-partition').className = 'cap-item active';
            document.getElementById('cap-availability').className = 'cap-item inactive';
            document.getElementById('partition-status').textContent = 'Partitioned';
            document.getElementById('availability-status').textContent = 'Reduced';
            
            addLogEntry('warning', 'üö´ Network partition simulated - Server 1 isolated', 'capLog');
            addLogEntry('info', 'System maintains Consistency + Partition Tolerance', 'capLog');
        }

        function healPartition() {
            isPartitioned = false;
            document.getElementById('cap-partition').className = 'cap-item inactive';
            document.getElementById('cap-availability').className = 'cap-item active';
            document.getElementById('partition-status').textContent = 'No Partition';
            document.getElementById('availability-status').textContent = 'Active';
            
            addLogEntry('success', '‚úÖ Network partition healed', 'capLog');
        }

        async function testCAP() {
            addLogEntry('info', 'Starting CAP theorem test...', 'capLog');
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            addLogEntry('success', 'Phase 1: Normal operation - C‚úÖ A‚úÖ P-', 'capLog');
            
            simulateNetworkPartition();
            await new Promise(resolve => setTimeout(resolve, 3000));
            addLogEntry('warning', 'Phase 2: During partition - C‚úÖ A‚ùå P‚úÖ', 'capLog');
            
            healPartition();
            await new Promise(resolve => setTimeout(resolve, 2000));
            addLogEntry('success', 'Phase 3: After recovery - C‚úÖ A‚úÖ P-', 'capLog');
            
            document.getElementById('capAnalysis').innerHTML = `
                <p style="color: #4CAF50; font-size: 1.3em; margin-bottom: 10px;">
                    <strong>Consistency + Partition Tolerance (CP)</strong>
                </p>
                <p style="font-size: 1em; line-height: 1.6;">
                    Your system prioritizes data consistency over availability during network partitions.
                    When a partition occurs, the system sacrifices availability to maintain consistency.
                </p>
            `;
        }

        // Clock Comparison - Dynamic Updates
        let systemVectorClock = { Client: 0, 'Server-1': 0, 'Server-2': 0, 'Server-3': 0 };
        let systemLamportClock = 0;
        let clockEvolutionLog = [];

        function initializeClockDisplay() {
            updateVectorClockDisplay();
            updateLamportClockDisplay();
        }

        function updateVectorClockDisplay() {
            const display = document.getElementById('vectorClockDemo');
            if (!display) return;

            const clockStr = Object.entries(systemVectorClock)
                .map(([node, time]) => `${node}:${time}`)
                .join(', ');

            display.innerHTML = `
                <p style="opacity: 0.9; margin-bottom: 10px;">
                    <strong>Current Vector Clock State:</strong>
                </p>
                <div class="vector-clock" style="margin-top: 10px; font-size: 14px; padding: 12px;">
                    ${clockStr}
                </div>
                <p style="margin-top: 10px; color: #4CAF50; font-size: 0.9em;">
                    ‚úÖ Tracks each node independently<br>
                    ‚úÖ Can detect causality and concurrency
                </p>
            `;
        }

        function updateLamportClockDisplay() {
            const display = document.getElementById('lamportClockDemo');
            if (!display) return;

            display.innerHTML = `
                <p style="opacity: 0.9; margin-bottom: 10px;">
                    <strong>Current Lamport Clock State:</strong>
                </p>
                <div class="vector-clock" style="margin-top: 10px; font-size: 14px; padding: 12px;">
                    Global: ${systemLamportClock}
                </div>
                <p style="margin-top: 10px; color: #ff9800; font-size: 0.9em;">
                    ‚ö†Ô∏è Only tracks total order<br>
                    ‚ùå Cannot detect causality or concurrency
                </p>
            `;
        }

        function incrementVectorClock(nodeId) {
            if (!systemVectorClock[nodeId]) {
                systemVectorClock[nodeId] = 0;
            }
            systemVectorClock[nodeId]++;
            
            clockEvolutionLog.push({
                timestamp: new Date().toLocaleTimeString(),
                type: 'vector',
                node: nodeId,
                state: { ...systemVectorClock }
            });
            
            updateVectorClockDisplay();
            console.log(`Vector Clock updated for ${nodeId}:`, systemVectorClock);
        }

        function incrementLamportClock(nodeId) {
            systemLamportClock++;
            
            clockEvolutionLog.push({
                timestamp: new Date().toLocaleTimeString(),
                type: 'lamport',
                node: nodeId,
                state: systemLamportClock
            });
            
            updateLamportClockDisplay();
            console.log(`Lamport Clock updated: ${systemLamportClock} (node: ${nodeId})`);
        }

        function mergeVectorClock(incomingClock, nodeId) {
            // Merge incoming vector clock with local clock
            for (const [node, time] of Object.entries(incomingClock)) {
                if (!systemVectorClock[node] || systemVectorClock[node] < time) {
                    systemVectorClock[node] = time;
                }
            }
            // Increment current node
            incrementVectorClock(nodeId);
        }

        function updateLamportFromReceived(receivedTime, nodeId) {
            // Lamport clock update rule: max(local, received) + 1
            systemLamportClock = Math.max(systemLamportClock, receivedTime) + 1;
            
            clockEvolutionLog.push({
                timestamp: new Date().toLocaleTimeString(),
                type: 'lamport',
                node: nodeId,
                state: systemLamportClock,
                merged: true
            });
            
            updateLamportClockDisplay();
            console.log(`Lamport Clock merged: ${systemLamportClock} (received: ${receivedTime})`);
        }

        async function runVectorClockDemo() {
            addLogEntry('info', 'Running Vector Clock demonstration...', 'operationsLog');
            
            // Simulate a sequence of operations
            const operations = [
                { node: 'Client', action: 'Send request' },
                { node: 'Server-1', action: 'Process request' },
                { node: 'Server-1', action: 'Send to Server-2' },
                { node: 'Server-2', action: 'Process' },
                { node: 'Client', action: 'Concurrent operation' }
            ];

            for (const op of operations) {
                await new Promise(resolve => setTimeout(resolve, 800));
                incrementVectorClock(op.node);
                addLogEntry('info', `Vector: ${op.node} - ${op.action}`, 'operationsLog');
            }
            
            addLogEntry('success', 'Vector Clock demo complete - Clock shows per-node state', 'operationsLog');
        }

        async function runLamportClockDemo() {
            addLogEntry('info', 'Running Lamport Clock demonstration...', 'operationsLog');
            
            // Simulate same sequence with Lamport clocks
            const operations = [
                { node: 'Client', action: 'Send request' },
                { node: 'Server-1', action: 'Process request' },
                { node: 'Server-1', action: 'Send to Server-2' },
                { node: 'Server-2', action: 'Process' },
                { node: 'Client', action: 'Concurrent operation' }
            ];

            for (const op of operations) {
                await new Promise(resolve => setTimeout(resolve, 800));
                incrementLamportClock(op.node);
                addLogEntry('info', `Lamport: ${op.node} - ${op.action}`, 'operationsLog');
            }
            
            addLogEntry('success', 'Lamport Clock demo complete - Clock shows global order only', 'operationsLog');
        }

        async function runClockComparison() {
            addLogEntry('info', 'üï∞Ô∏è Starting clock comparison demonstration...', 'operationsLog');
            
            // Reset clocks for fair comparison
            systemVectorClock = { Client: 0, 'Server-1': 0, 'Server-2': 0, 'Server-3': 0 };
            systemLamportClock = 0;
            updateVectorClockDisplay();
            updateLamportClockDisplay();
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Run both demos
            await runVectorClockDemo();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Reset Lamport for comparison
            systemLamportClock = 0;
            await runLamportClockDemo();
            
            addLogEntry('info', 'üìä Comparison complete - Check both clock displays', 'operationsLog');
            addLogEntry('success', `Vector Clock: ${Object.keys(systemVectorClock).length} nodes tracked individually`, 'operationsLog');
            addLogEntry('success', `Lamport Clock: Single global counter at ${systemLamportClock}`, 'operationsLog');
        }

        function showClockEvolutionLog() {
            if (clockEvolutionLog.length === 0) {
                addLogEntry('info', 'No clock events yet. Run operations or demos first.', 'operationsLog');
                return;
            }

            addLogEntry('info', 'üìã Clock Evolution Log:', 'operationsLog');
            clockEvolutionLog.slice(-10).forEach(log => {
                const stateStr = log.type === 'vector' 
                    ? Object.entries(log.state).map(([k, v]) => `${k}:${v}`).join(', ')
                    : `Global: ${log.state}`;
                addLogEntry('info', `[${log.timestamp}] ${log.type.toUpperCase()} - ${log.node}: ${stateStr}`, 'operationsLog');
            });
        }

        // Leader Election
        function initializeLeaderElection() {
            const grid = document.getElementById('leaderServersGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            servers.forEach((server, index) => {
                const isLeader = index === 0; // Initial leader is Server 1
                const card = document.createElement('div');
                card.className = `server-card ${isLeader ? 'leader' : ''}`;
                card.id = `leader-server-${server.id}`;
                card.innerHTML = `
                    <div class="server-status">
                        <div class="status-dot" id="leader-status-${server.id}"></div>
                        <strong>${server.name}</strong>
                        <span id="leader-crown-${server.id}" style="font-size: 1.2em; margin-left: 5px;">${isLeader ? 'üëë' : ''}</span>
                    </div>
                    <div id="leader-role-${server.id}">${isLeader ? 'LEADER' : 'Follower'}</div>
                    <div style="margin-top: 5px; font-size: 0.9em; color: #ccc;">Port: ${server.port}</div>
                `;
                grid.appendChild(card);
            });
            
            if (!currentLeaderAddress) {
                currentLeaderAddress = servers[0].url;
                updateCurrentLeaderDisplay();
            }
        }

        function updateCurrentLeaderDisplay() {
            const leaderDisplay = document.getElementById('currentLeader');
            if (leaderDisplay) {
                const leader = servers.find(s => s.url === currentLeaderAddress);
                if (leader) {
                    leaderDisplay.textContent = `${leader.name} (${leader.url})`;
                }
            }
        }

        function setLeader(serverUrl) {
            // Remove leader status from all servers
            servers.forEach(server => {
                const card = document.getElementById(`leader-server-${server.id}`);
                const crown = document.getElementById(`leader-crown-${server.id}`);
                const role = document.getElementById(`leader-role-${server.id}`);
                
                if (card) {
                    card.classList.remove('leader');
                }
                if (crown) {
                    crown.textContent = '';
                }
                if (role) {
                    role.textContent = 'Follower';
                }
            });

            // Set new leader
            const newLeader = servers.find(s => s.url === serverUrl);
            if (newLeader) {
                const card = document.getElementById(`leader-server-${newLeader.id}`);
                const crown = document.getElementById(`leader-crown-${newLeader.id}`);
                const role = document.getElementById(`leader-role-${newLeader.id}`);
                
                if (card) {
                    card.classList.add('leader');
                    // Animate the crown appearance
                    card.style.animation = 'nodeActivity 0.5s ease-in-out';
                    setTimeout(() => {
                        card.style.animation = '';
                    }, 500);
                }
                if (crown) {
                    crown.textContent = 'üëë';
                    // Animate crown
                    crown.style.animation = 'pulse 1s ease-in-out';
                    setTimeout(() => {
                        crown.style.animation = '';
                    }, 1000);
                }
                if (role) {
                    role.textContent = 'LEADER';
                    role.style.fontWeight = 'bold';
                    role.style.color = '#ffd700';
                }
                
                currentLeaderAddress = serverUrl;
                updateCurrentLeaderDisplay();
            }
        }

        function electLeader() {
            const availableServers = servers.filter(s => {
                const card = document.getElementById(`leader-server-${s.id}`);
                return card && !card.classList.contains('offline');
            });
            
            if (availableServers.length === 0) {
                addLogEntry('error', 'No available servers for election', 'leaderLog');
                return;
            }

            const newLeader = availableServers[Math.floor(Math.random() * availableServers.length)];
            
            addLogEntry('info', 'üó≥Ô∏è Leader election triggered', 'leaderLog');
            addLogEntry('info', `Candidates: ${availableServers.map(s => s.name).join(', ')}`, 'leaderLog');
            
            setTimeout(() => {
                setLeader(newLeader.url);
                addLogEntry('success', `üëë New leader elected: ${newLeader.name}`, 'leaderLog');
                
                const oldLeader = servers.find(s => s.url === currentLeaderAddress && s.url !== newLeader.url);
                if (oldLeader) {
                    addLogEntry('info', `Previous leader ${oldLeader.name} demoted to follower`, 'leaderLog');
                }
            }, 500);
        }

        function killLeader() {
            const currentLeader = servers.find(s => s.url === currentLeaderAddress);
            if (!currentLeader) {
                addLogEntry('error', 'No current leader to kill', 'leaderLog');
                return;
            }

            addLogEntry('error', `üíÄ Current leader killed: ${currentLeader.name}`, 'leaderLog');
            
            // Mark leader as dead
            const leaderCard = document.getElementById(`leader-server-${currentLeader.id}`);
            const leaderStatus = document.getElementById(`leader-status-${currentLeader.id}`);
            
            if (leaderCard) {
                leaderCard.classList.remove('leader');
                leaderCard.classList.add('offline');
            }
            if (leaderStatus) {
                leaderStatus.classList.add('offline');
            }
            
            // Remove crown from dead leader
            const crown = document.getElementById(`leader-crown-${currentLeader.id}`);
            if (crown) {
                crown.textContent = 'üíÄ';
            }
            
            addLogEntry('warning', '‚ö° Failure detected! Starting automatic election...', 'leaderLog');
            
            // Automatic failover after 2 seconds
            setTimeout(() => {
                const availableServers = servers.filter(s => s.id !== currentLeader.id);
                
                if (availableServers.length > 0) {
                    const newLeader = availableServers[Math.floor(Math.random() * availableServers.length)];
                    setLeader(newLeader.url);
                    addLogEntry('success', `üîÑ Automatic failover completed`, 'leaderLog');
                    addLogEntry('success', `üëë New leader elected: ${newLeader.name}`, 'leaderLog');
                } else {
                    addLogEntry('error', 'üíÄ No available servers for failover!', 'leaderLog');
                }
            }, 2000);
        }

        async function testLeaderFailover() {
            const currentLeader = servers.find(s => s.url === currentLeaderAddress);
            if (!currentLeader) {
                addLogEntry('error', 'No current leader', 'leaderLog');
                return;
            }

            addLogEntry('info', 'üîÑ Starting leader failover test...', 'leaderLog');
            addLogEntry('info', `Current leader: ${currentLeader.name}`, 'leaderLog');
            
            const startTime = Date.now();
            
            // Kill current leader
            await new Promise(resolve => setTimeout(resolve, 1000));
            killLeader();
            
            // Wait for failover to complete
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            const failoverTime = ((Date.now() - startTime) / 1000).toFixed(1);
            
            addLogEntry('success', `‚úÖ Failover test completed in ${failoverTime} seconds`, 'leaderLog');
            
            const newLeader = servers.find(s => s.url === currentLeaderAddress);
            if (newLeader) {
                addLogEntry('info', `New leader: ${newLeader.name}`, 'leaderLog');
            }
        }

        // Two-Phase Commit
        function initializeTwoPhaseCommit() {
            const grid = document.getElementById('tpcParticipantsGrid');
            if (!grid || grid.children.length > 0) return;
            
            grid.innerHTML = '';
            servers.forEach(server => {
                const card = document.createElement('div');
                card.className = 'server-card';
                card.innerHTML = `
                    <div class="server-status">
                        <div class="status-dot"></div>
                        <strong>${server.name}</strong>
                    </div>
                    <div>Status: Ready</div>
                `;
                grid.appendChild(card);
            });
        }

        async function runTwoPhaseCommit() {
            const type = document.getElementById('transactionType').value;
            const num1 = parseFloat(document.getElementById('tpc-number1').value);
            const num2 = parseFloat(document.getElementById('tpc-number2').value);
            
            const result = document.getElementById('tpcResult');
            result.innerHTML = '<div class="loading"></div> Executing transaction...';
            
            // Phase 1: Prepare
            document.getElementById('prepareStatus').textContent = 'In Progress...';
            addLogEntry('info', 'üìã PREPARE phase started', 'tpcLog');
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            const prepareSuccess = Math.random() > 0.3;
            if (prepareSuccess) {
                document.getElementById('prepareStatus').textContent = 'All YES ‚úÖ';
                addLogEntry('success', 'üìã PREPARE phase: All participants ready', 'tpcLog');
                
                // Phase 2: Commit
                document.getElementById('commitStatus').textContent = 'Committing...';
                addLogEntry('info', '‚úÖ COMMIT phase started', 'tpcLog');
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                document.getElementById('commitStatus').textContent = 'Committed ‚úÖ';
                addLogEntry('success', '‚úÖ COMMIT phase: Transaction successful', 'tpcLog');
                
                const calcResult = type === 'square' ? num1 * num1 : 
                                 type === 'cube' ? num1 * num1 * num1 : 
                                 num1 * num2;
                result.innerHTML = `‚úÖ Transaction Committed! Result: ${calcResult}`;
            } else {
                document.getElementById('prepareStatus').textContent = 'Some NO ‚ùå';
                document.getElementById('abortStatus').textContent = 'Aborting...';
                addLogEntry('error', '‚ùå PREPARE phase: Some participants failed', 'tpcLog');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                document.getElementById('abortStatus').textContent = 'Aborted ‚úÖ';
                addLogEntry('warning', 'üîÑ ABORT phase: Transaction rolled back', 'tpcLog');
                result.innerHTML = '‚ùå Transaction Aborted - All changes rolled back';
            }
            
            setTimeout(() => {
                document.getElementById('prepareStatus').textContent = 'Waiting...';
                document.getElementById('commitStatus').textContent = 'Waiting...';
                document.getElementById('abortStatus').textContent = 'Not triggered';
            }, 3000);
        }

        // Eventual Consistency
        async function startConsistencyTest() {
            if (consistencyTestRunning) return;
            consistencyTestRunning = true;
            
            addLogEntry('info', 'üîÉ Starting eventual consistency test...', 'consistencyLog');
            
            let progress = 0;
            const interval = setInterval(() => {
                if (!consistencyTestRunning) {
                    clearInterval(interval);
                    return;
                }
                
                progress += 10;
                if (progress > 100) progress = 100;
                
                document.getElementById('convergenceProgress').style.width = progress + '%';
                document.getElementById('convergenceProgress').textContent = progress + '%';
                document.getElementById('convergenceTime').textContent = 
                    progress < 100 ? 'Converging...' : 'Convergence achieved in 15.3 seconds!';
                
                if (progress === 100) {
                    addLogEntry('success', '‚úÖ All nodes synchronized', 'consistencyLog');
                    consistencyTestRunning = false;
                }
            }, 500);
        }

        function stopConsistencyTest() {
            consistencyTestRunning = false;
            addLogEntry('warning', 'Consistency test stopped', 'consistencyLog');
        }

        function forceSynchronization() {
            addLogEntry('info', 'üîÑ Forcing immediate synchronization...', 'consistencyLog');
            document.getElementById('convergenceProgress').style.width = '100%';
            document.getElementById('convergenceProgress').textContent = '100%';
            document.getElementById('convergenceTime').textContent = 'Force sync completed!';
            addLogEntry('success', '‚úÖ All clocks synchronized', 'consistencyLog');
        }

        // Gossip Protocol
        function initializeGossipNetwork() {
            const viz = document.getElementById('gossipNetworkViz');
            if (!viz || viz.querySelector('.node')) return;
            
            viz.innerHTML = '';
            
            // Create network topology for gossip
            const positions = [
                { left: '20%', top: '30%' },
                { left: '50%', top: '20%' },
                { left: '80%', top: '30%' },
                { left: '35%', top: '70%' },
                { left: '65%', top: '70%' }
            ];

            positions.forEach((pos, index) => {
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `gossip-node-${index}`;
                node.innerHTML = `N${index + 1}`;
                node.style.left = pos.left;
                node.style.top = pos.top;
                node.style.transform = 'translate(-50%, -50%)';
                viz.appendChild(node);
            });
        }

        let gossipInterval;
        let gossipRoundCount = 0;
        let gossipMessageCount = 0;

        async function startGossipProtocol() {
            if (gossipProtocolRunning) return;
            
            gossipProtocolRunning = true;
            gossipRoundCount = 0;
            gossipMessageCount = 0;
            
            const interval = parseInt(document.getElementById('gossipInterval').value) * 1000;
            
            addLogEntry('info', `üì£ Starting gossip protocol (interval: ${interval/1000}s)`, 'gossipLog');
            
            initializeGossipNetwork();
            
            gossipInterval = setInterval(() => {
                performGossipRound();
            }, interval);
        }

        function stopGossipProtocol() {
            if (gossipInterval) {
                clearInterval(gossipInterval);
                gossipInterval = null;
            }
            gossipProtocolRunning = false;
            addLogEntry('warning', 'üì£ Gossip protocol stopped', 'gossipLog');
        }

        async function performGossipRound() {
            gossipRoundCount++;
            
            // Select random pair of nodes to gossip
            const nodeCount = 5;
            const node1 = Math.floor(Math.random() * nodeCount);
            let node2 = Math.floor(Math.random() * nodeCount);
            while (node2 === node1) {
                node2 = Math.floor(Math.random() * nodeCount);
            }
            
            // Animate nodes
            const elem1 = document.getElementById(`gossip-node-${node1}`);
            const elem2 = document.getElementById(`gossip-node-${node2}`);
            
            if (elem1 && elem2) {
                elem1.classList.add('active');
                elem2.classList.add('active');
                
                setTimeout(() => {
                    elem1.classList.remove('active');
                    elem2.classList.remove('active');
                }, 800);
            }
            
            gossipMessageCount += 2;
            
            addLogEntry('info', `üì§ Gossip round ${gossipRoundCount}: N${node1+1} ‚Üî N${node2+1}`, 'gossipLog');
            
            // Update stats
            document.getElementById('gossipRounds').textContent = gossipRoundCount;
            document.getElementById('messagesExchanged').textContent = gossipMessageCount;
            
            // Simulate convergence
            const convergenceProgress = Math.min((gossipRoundCount / 10) * 100, 100);
            document.getElementById('gossipProgress').style.width = convergenceProgress + '%';
            document.getElementById('gossipProgress').textContent = Math.round(convergenceProgress) + '%';
            
            if (convergenceProgress === 100 && document.getElementById('convergenceRounds').textContent === '-') {
                document.getElementById('convergenceRounds').textContent = gossipRoundCount;
                document.getElementById('gossipConvergenceTime').textContent = 
                    `Converged after ${gossipRoundCount} rounds (${gossipRoundCount * parseInt(document.getElementById('gossipInterval').value)}s)`;
                addLogEntry('success', `üéâ Network converged after ${gossipRoundCount} gossip rounds!`, 'gossipLog');
            }
        }

        // Initialize on load
        window.addEventListener('load', function() {
            // Simulate some initial activity
            setTimeout(() => {
                addLogEntry('info', 'System ready - All servers online', 'operationsLog');
                initializeClockDisplay();
            }, 1000);
        });

        // Export functionality for testing
        window.dashboardAPI = {
            addLog: addLogEntry,
            updateServerStatus: function(serverId, status) {
                const statusDot = document.getElementById(`status-${serverId}`);
                const serverCard = document.getElementById(`server-${serverId}`);
                
                if (status === 'online') {
                    statusDot.className = 'status-dot';
                    serverCard.className = 'server-card';
                } else if (status === 'offline') {
                    statusDot.className = 'status-dot offline';
                    serverCard.className = 'server-card offline';
                } else if (status === 'partitioned') {
                    statusDot.className = 'status-dot partitioned';
                    serverCard.className = 'server-card partitioned';
                }
            },
            updateClock: function(nodeId, clockValue) {
                if (nodeId === 'client') {
                    clientClock = clockValue;
                    updateClientClock();
                } else {
                    const serverId = getServerIdFromUrl(`http://localhost:${nodeId}`);
                    serverClocks[serverId] = clockValue;
                    updateServerClock(serverId);
                }
            },
            recordOperation: function(success, responseTime) {
                operationCount++;
                if (success) {
                    successCount++;
                } else {
                    failureCount++;
                }
                responseTimes.push(responseTime);
                updateStats();
            }
        };
    </script>
</body>
</html>